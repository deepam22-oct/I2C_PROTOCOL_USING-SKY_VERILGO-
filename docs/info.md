# I2C Controller Design Documentation

## Overview

This document describes a complete I2C (Inter-Integrated Circuit) controller implementation in Verilog, designed for use in a TinyTapeout project. The design includes both master and slave functionality with proper signal arbitration and bidirectional I/O handling.

## Architecture

The design consists of three main modules:

1. **`tt_um_example`** - Top-level wrapper for TinyTapeout integration
2. **`i2c_top`** - System-level module with bus arbitration
3. **`i2c_controller`** - Master controller implementation
4. **`i2c_slave_controller`** - Slave controller implementation

## Module Descriptions

### 1. tt_um_example (Top-Level Wrapper)

This module provides the interface between the TinyTapeout framework and the I2C system.

#### Port Mapping
```verilog
input  wire [7:0] ui_in     // Dedicated inputs
output wire [7:0] uo_out    // Dedicated outputs  
input  wire [7:0] uio_in    // Bidirectional I/O inputs
output wire [7:0] uio_out   // Bidirectional I/O outputs
output wire [7:0] uio_oe    // Bidirectional I/O output enables
```

#### Signal Assignments
- `ui_in[6:0]` → I2C slave address (7-bit)
- `ui_in[7]` → Enable signal for master operation
- `uio_in[7:0]` → Data input for write operations
- `uio_in[7]` → Read/Write control bit (0=write, 1=read)
- `uio_in[0]` → SDA input line
- `uio_in[1]` → SCL input line
- `uo_out[7:0]` → Data output from read operations
- `uio_out[0]` → SDA output line
- `uio_out[1]` → SCL output line
- `uio_out[7]` → Ready status signal
- `uio_oe[0]` → SDA output enable
- `uio_oe[1]` → SCL output enable

### 2. i2c_top (System Controller)

Manages bus arbitration between master and slave controllers.

#### Features
- Master has priority over slave for bus control
- Proper tri-state buffer management
- Instantiates both master and slave controllers

#### Bus Arbitration Logic
```verilog
assign sda_out = master_sda_oe ? i2c_sda_master : 
                (slave_sda_oe ? i2c_sda_slave : 1'b1);
assign scl_out = master_scl_oe ? i2c_scl_master : 1'b1;
```

### 3. i2c_controller (Master)

Implements I2C master functionality with full transaction support.

#### State Machine States
- **IDLE**: Waiting for enable signal
- **START**: Generate start condition
- **ADDRESS**: Send 7-bit address + R/W bit
- **READ_ACK**: Read acknowledgment from slave
- **WRITE_DATA**: Send data byte (write operations)
- **READ_DATA**: Receive data byte (read operations)
- **WRITE_ACK**: Send acknowledgment (read operations)
- **READ_ACK2**: Read final acknowledgment (write operations)
- **STOP**: Generate stop condition

#### Clock Generation
- Internal I2C clock is generated by dividing the system clock
- Default division factor: `DIVIDE_BY = 4`
- I2C clock frequency = System clock / (2 × DIVIDE_BY)

#### Transaction Flow

**Write Transaction:**
1. IDLE → START → ADDRESS → READ_ACK → WRITE_DATA → READ_ACK2 → STOP → IDLE

**Read Transaction:**
1. IDLE → START → ADDRESS → READ_ACK → READ_DATA → WRITE_ACK → STOP → IDLE

#### Key Features
- Automatic start/stop condition generation
- Proper setup and hold time handling
- ACK/NACK detection and generation
- Ready signal indicates when controller is available

### 4. i2c_slave_controller (Slave)

Implements I2C slave functionality with configurable address.

#### Parameters
- `ADDRESS`: 7-bit slave address (default: 7'b0101010 = 0x2A)

#### State Machine States
- **READ_ADDR**: Receive address byte
- **SEND_ACK**: Send acknowledgment if address matches
- **READ_DATA**: Receive data from master (write to slave)
- **WRITE_DATA**: Send data to master (read from slave)
- **SEND_ACK2**: Send acknowledgment after receiving data

#### Features
- Automatic start/stop condition detection
- Address matching with configurable slave address
- Default read data: `8'b11001100` (0xCC)
- Proper ACK generation for matched addresses

## Signal Timing and Protocol

### I2C Protocol Implementation

The implementation follows standard I2C protocol specifications:

#### Start Condition
- SDA transitions from HIGH to LOW while SCL is HIGH
- Generated by master to initiate communication

#### Stop Condition  
- SDA transitions from LOW to HIGH while SCL is HIGH
- Generated by master to end communication

#### Data Transfer
- Data is stable when SCL is HIGH
- Data changes when SCL is LOW
- MSB transmitted first

#### Acknowledgment
- After each 8-bit transfer, receiver pulls SDA LOW during 9th clock cycle
- Missing ACK indicates transaction failure

### Clock Synchronization

The master generates SCL, but the implementation includes provisions for clock stretching:
- Slaves can hold SCL LOW to extend clock periods
- Master should monitor SCL input for proper synchronization

## Common Issues and Debugging

### 1. Signal Conflicts
**Problem**: Multiple drivers on SDA/SCL lines
**Solution**: Ensure proper tri-state control using `sda_oe` and `scl_oe` signals

### 2. Timing Violations
**Problem**: Setup/hold time violations
**Solution**: 
- Adjust `DIVIDE_BY` parameter for slower I2C clock
- Ensure data changes only on SCL falling edge
- Sample data only on SCL rising edge

### 3. ACK Issues
**Problem**: No acknowledgment received
**Solutions**:
- Verify slave address matches
- Check pull-up resistors on SDA/SCL
- Ensure proper tri-state control during ACK cycles

### 4. Start/Stop Detection
**Problem**: False start/stop detection
**Solution**:
- Implement proper edge detection with previous state comparison
- Filter glitches with stable sampling

### 5. State Machine Lockup
**Problem**: State machine stuck in non-IDLE state
**Solutions**:
- Implement timeout mechanisms
- Add proper reset handling
- Include default cases in state machines

## Usage Examples

### Master Write Operation
```verilog
// Setup
ui_in = 8'b1_0101010;     // Enable=1, Address=0x2A
uio_in = 8'b01100110;     // Data=0x66, R/W=0 (write)

// Wait for ready
wait(uo_out[7] == 1);     // Wait for ready signal

// Transaction completes automatically
```

### Master Read Operation
```verilog
// Setup  
ui_in = 8'b1_0101010;     // Enable=1, Address=0x2A
uio_in = 8'b11111111;     // R/W=1 (read)

// Wait for completion
wait(uo_out[7] == 1);     // Wait for ready signal

// Read data
read_data = uo_out[7:0];  // Get received data
```

## Synthesis Considerations

### Resource Usage
- **Logic Elements**: Approximately 200-300 LEs
- **Memory**: No external memory required
- **I/O Pins**: 2 bidirectional pins (SDA, SCL) + control signals

### Timing Constraints
- Set appropriate clock constraints for system clock
- Consider I2C timing requirements (standard: 100kHz, fast: 400kHz)
- Add timing constraints for I/O pins

### Physical Implementation
- Ensure proper pull-up resistors on SDA and SCL lines
- Consider signal integrity for longer traces
- Add appropriate decoupling capacitors

## Testing and Verification

### Testbench Requirements
1. **Clock Generation**: Provide stable system clock
2. **Reset Sequence**: Test proper reset behavior
3. **Transaction Tests**: Verify read/write operations
4. **Error Conditions**: Test NACK, timeout scenarios
5. **Multi-Master**: Test bus arbitration (if implemented)

### Debug Signals
- Monitor internal state machines
- Check I2C clock generation
- Verify tri-state control signals
- Observe start/stop condition detection

## Modifications and Enhancements

### Possible Improvements
1. **Multi-Master Support**: Add collision detection
2. **Clock Stretching**: Full slave clock stretching support
3. **FIFO Buffers**: Add data buffering for continuous transfers
4. **Interrupt Generation**: Add interrupt signals for transaction completion
5. **Error Reporting**: Detailed error status reporting
6. **Configurable Timing**: Runtime configurable I2C speed

### Parameter Customization
- Modify `DIVIDE_BY` for different I2C clock speeds
- Change slave `ADDRESS` parameter for different slave addresses
- Adjust state machine timing for specific requirements

## How it works

The I2C controller operates through a hierarchical state machine architecture that manages both master and slave functionality:

### Master Operation Flow
1. **Initialization**: When `enable` is asserted, the controller captures the target address and data
2. **Start Condition**: SDA is pulled low while SCL remains high to signal start of transmission
3. **Address Phase**: The 7-bit slave address plus R/W bit is transmitted MSB first
4. **Acknowledgment**: Controller releases SDA and waits for slave acknowledgment (SDA low)
5. **Data Phase**: For writes, master sends data byte; for reads, master receives data from slave
6. **Stop Condition**: SCL goes high followed by SDA high to end the transaction

### Clock Generation
The internal I2C clock is derived from the system clock using a configurable divider (`DIVIDE_BY = 4`). This ensures proper setup and hold times for reliable data transfer.

### Bus Arbitration
The design implements a priority-based system where the master controller has precedence over the slave. Tri-state buffers controlled by output enable signals prevent bus conflicts.

### Slave Operation
The slave controller continuously monitors the bus for its assigned address (default: 0x2A). Upon address match, it responds with acknowledgment and either accepts write data or provides read data (default: 0xCC).

### Signal Timing
- Data is stable during SCL high periods
- Data transitions occur during SCL low periods  
- Start/stop conditions are detected by monitoring SDA transitions while SCL is high
- The ready signal indicates when the master is available for new transactions

## Conclusion

This I2C controller implementation provides a complete solution for I2C communication in FPGA designs. The modular structure allows for easy integration and customization while maintaining protocol compliance. Proper attention to timing, tri-state control, and state machine design ensures reliable operation in various system configurations.
